<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>i5ting_ztree_toc:node进阶</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<h2 id="node-">node进阶</h2>
<h3 id="-">目标</h3>
<blockquote>
<p>什么是nodejs的模块化</p>
<p>npm的使用</p>
<p>使用第三方模块</p>
<p>node中的自定义模块</p>
<p>模块查找规则</p>
<p>案例</p>
</blockquote>
<h3 id="-">程序开发中的模块及好处</h3>
<ul>
<li>什么是程序开发中的模块化：把一些功能类似的代码，封装到一个单独的文件中去，这些单独抽离出来的代码文件，就能够提供各种各样好用的功能；这种通过代码功能分割文件的方式，叫做程序中的模块化；</li>
<li><p>好处：保证了每个文件的功能（职能）单一；需要什么特定的功能，直接调用某一个特定的模块；对将来程序开发和维护都有好处！对于整个系统来说，模块是可组合、分解和更换的单元</p>
<ul>
<li>提高了代码的复用性</li>
<li>提高了代码的可维护性</li>
<li>可以实现按需加载</li>
</ul>
<p>​</p>
</li>
</ul>
<p><img src=".\image-20201229175929044.png" alt="image-20201229175929044" style="zoom: 67%;" /></p>
<h3 id="node-">Node 中的模块</h3>
<blockquote>
<p>node由三部分组成：ECMAScript + 核心模块 + 第三方模块</p>
</blockquote>
<h4 id="-">核心模块</h4>
<ul>
<li>什么是核心模块：官方发现一些功能模块使用非常频繁，所以官方把这些模块，编译成了二进制可执行文件，打包到了Node的安装包中；这些核心模块就已经随着安装Node时候，被安装到了本地；</li>
<li>如何使用核心模块
使用require（‘核心模块的名称’）；</li>
</ul>
<h4 id="-">第三方模块</h4>
<ul>
<li>什么是第三方模块：除了官方提供的好用的核心模块之外，我们程序员发现，还有一些使用也很频繁的代码和方法，一些牛逼的团体、个人、公司，开发出了好用的模块，通过NPM官网，托管出去，供其他人下载使用的这些模块；统称为第三方模块；</li>
<li>我们在开发的过程中，经常需要使用到各种各样的第三方模块</li>
</ul>
<h4 id="-">自定义模块</h4>
<ul>
<li>自定义模块也称为用户用户模块</li>
<li>什么是自定义模块：由于业务的需要，程序员自己定义的完成某些特定功能的JS文件，统统称为用户模块！</li>
</ul>
<h4 id="-">加载模块</h4>
<blockquote>
<p>使用强大的 require() 方法，可以加载需要的内置模块、用户自定义模块、第三方模块进行使用。</p>
<p>使用 require() 方法加载其它模块时，会<strong>执行</strong>被加载模块中的代码</p>
</blockquote>
<p><img src="F:\前端项目\node\node\02-上课笔记\node进阶讲义\images\加载模块.png" alt="加载模块"></p>
<h4 id="-">什么是模块作用域</h4>
<blockquote>
<p>和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做<strong>模块作用域</strong></p>
</blockquote>
<ul>
<li>防止了全局变量污染的问题</li>
</ul>
<h3 id="npm-">npm的使用</h3>
<h4 id="npm">npm</h4>
<blockquote>
<p>通过npm我们可以下载项目中所需要的第三方模块</p>
<p>第三方模块俗称包，下载第三方模块也称为下包</p>
</blockquote>
<ul>
<li>全称：node package manager</li>
<li>官方推出的包管理工具</li>
<li>不需要额外安装，安装node之后自带</li>
<li>因为服务器不在国内，所以有时候安装特别慢，甚至无法成功</li>
</ul>
<h4 id="npm-">npm使用流程</h4>
<ul>
<li>初始化：在当前nodejs项目中执行终端命名: <code>npm init -y</code><ul>
<li>作用：生成一个<code>pachage.json</code>文件，帮你记录当前项目安装了哪些第三方模块及对应的版本号</li>
<li>上述命令只能在英文的目录下成功运行！所以，项目文件夹的名称一定要使用英文命名，不要使用中文，不能出现空格</li>
</ul>
</li>
<li>安装：在当前nodejs项目中执行终端命名: <code>npm install 模块名</code><ul>
<li>安装之后，你的项目目录会新增两个文件<code>node_modules</code>与<code>package-lock.json</code><ul>
<li>node_modules:npm会自动将所有的第三方模块放入这个文件夹中。类似于前端的<code>lib文件夹</code></li>
<li>package.json：npm会自动记录第三方模块的下载地址，下一次安装或更新的时候直接从这个地址下载，速度更快(只是影响以后更新速度，不影响开发)</li>
<li>注意：程序员不要手动修改 node_modules 或 package-lock.json 文件中的任何代码，npm 包管理工具会自动维护它们</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="npm-">npm常用命令</h4>
<ul>
<li>npm init -y:初始化</li>
<li>npm install 包名 包类型<ul>
<li>install可以简写为i</li>
<li>--save | -S:安装部署依赖包，开发和部署都需要使用的包，会被记录到 devDependencies 节点中的包，只在开发期间会用到</li>
<li>--save-dev | -D:安装开发依赖包，只有开发的时候才需要使用，被记录到 dependencies 节点中的包，在开发期间和项目上线之后都会用到</li>
<li>-g:安装全局包<ul>
<li>只有工具性质的包，才有全局安装的必要性。因为它们提供了好用的终端命令</li>
<li>判断某个包是否需要全局安装后才能使用，可以参考官方提供的使用说明即可</li>
<li>全局包会被安装到 C:\Users\用户目录\AppData\Roaming\npm\node_modules 目录下</li>
</ul>
</li>
</ul>
</li>
<li>npm uninstall 包名 类型：卸载包</li>
<li>npm i :当我们拿到一个剔除了 node_modules 的项目之后，需要先把所有的包下载到项目中，才能将项目运行起来,这个时候，可以运行 npm install 命令（或 npm i）一次性安装所有的依赖包</li>
</ul>
<h4 id="nrm">nrm</h4>
<blockquote>
<p>在使用 npm 下包的时候，默认从国外的 <a href="https://registry.npmjs.org/">https://registry.npmjs.org/</a> 服务器进行下载，此时，网络数据的传输需要经</p>
<p>过漫长的海底光缆，因此下包速度会很慢，甚至不成功，这个时候我们就可以通过nrm切换镜像源，提高下载包的成功率</p>
</blockquote>
<p><img src="F:\前端项目\node\node\02-上课笔记\node进阶讲义\images\nrm.png" alt="nrm"></p>
<p>1.安装：</p>
<pre><code class="lang-js">npm install -g nrm
</code></pre>
<p>2.查看当前及所有可用的源</p>
<pre><code class="lang-js">$ nrm ls
// * 代码当前源
* npm -----  https://registry.npmjs.org/
  yarn ----- https://registry.yarnpkg.com
  cnpm ----  http://r.cnpmjs.org/
  taobao --  https://registry.npm.taobao.org/
  nj ------  https://registry.nodejitsu.com/
  skimdb -- https://skimdb.npmjs.com/registry
</code></pre>
<p>3.切换当前的源</p>
<pre><code class="lang-js">$ nrm use cnpm  // 切换到cnpm

    Registry has been set to: http://r.cnpmjs.org/
</code></pre>
<p>4.补充，如果不使用nrm(或者nrm没有成功的安装),也可以通过命令的方式直接切换镜像源</p>
<p><img src="F:\前端项目\node\node\02-上课笔记\node进阶讲义\images\命令直接切换镜像源.png" alt="命令直接切换镜像源"></p>
<h3 id="-">第三方模块的使用</h3>
<ol>
<li><p>就像电脑和计算机指的是相同的东西，第三方模块和包指的是同一个概念，只不过叫法不同,不同于 Node.js 中的内置模块与自定义模块，包是由第三方个人或团队开发出来的，免费供所有人使用</p>
</li>
<li><p>先使用npm下载这个模块！【注意：在安装第三方模块的时候，安装的名字，就是你在require时候导入的名字】</p>
</li>
<li><p>使用require导入这个第三方模块！</p>
</li>
<li><p>通过官方文档，试着去使用这个第三方模块！</p>
</li>
<li><p>注意：无论是核心模块、还是第三方模块，都是通过 require来引用这个模块的！</p>
</li>
<li><p>一个简单的第三方模块使用的案例</p>
<pre><code class="lang-js">// 这个文件演示一下如果使用第三方模块moment实现日期数据的格式化处理
// 1. 引入moment（引入之前确保这个模块已经正确的下载哦）
const moment = require(&#39;moment&#39;)

// 2.定义一个日期，现在日期值是未格式化的日期数据
let timeNow = new Date()

// 3.调用moment实现对日期数据的格式化处理
console.log(moment(timeNow).format(&#39;YYYY-MM-DD HH:mm:ss&#39;))
</code></pre>
</li>
</ol>
<h3 id="node-">node中的自定义模块</h3>
<blockquote>
<p>程序员自己定义的JS文件，统统数据用户模块</p>
</blockquote>
<h4 id="-">定义用户模块</h4>
<p>用户自己的添加能够实现某些功能的js文件，都可以认为是用户自定义模块</p>
<h4 id="-">导出用户模块中的成员</h4>
<h5 id="exports">exports</h5>
<blockquote>
<p>它是一个对象，我们可以在这个对象上挂载你想暴露的成员</p>
<p>使用.语法在exports上挂载成员</p>
</blockquote>
<p>1.定义用户模块</p>
<pre><code class="lang-js">// 我们所创建的js文件就可以认为是一个自定义模块
var obj = {
    name:&#39;jack&#39;,
    age:20
}

function sayHi(){
    console.log(&#39;我的名字叫：&#39;+obj.name+&quot;,我的年龄是：&quot;+obj.age)
}

// 在模块中有一个默认的对象exports,这个对象在在这个模块被引入的时候会自动的返回
// 我们暴露成员的方式就是在这个对象上挂载你想暴露的成员
exports.sayHi = sayHi
exports.aa = obj
</code></pre>
<p>2.使用用户模块</p>
<pre><code class="lang-js">// 如何使用用户自定义模块：
// 所有模块想使用都要先引入
// 如果引入一个模块，那么这个模块默认会返回一个对象
var umodule = require(&#39;你想引入的模块路径&#39;)
umodule.sayHi()
</code></pre>
<h5 id="module-exports">module.exports</h5>
<blockquote>
<p>它是一个对象，我们可以在这个对象上挂载你想暴露的成员</p>
<p>使用.语法在module.exports上挂载成员</p>
<p>也可以将module.exports重置为一个新的对象，对象中就包含你想暴露的成员</p>
</blockquote>
<p>1.定义用户模块</p>
<pre><code class="lang-js">// 我们所创建的js文件就可以认为是一个自定义模块
var obj = {
    name:&#39;jack&#39;,
    age:20
}

function sayHi(){
    console.log(&#39;我的名字叫：&#39;+obj.name+&quot;,我的年龄是：&quot;+obj.age)
}

// 在模块中有一个默认的对象module.exports,这个对象在在这个模块被引入的时候会自动的返回
// 我们暴露成员的方式就是在这个对象上挂载你想暴露的成员

// module.exports.sayHi = sayHi
// module.exports.aa = obj
// 也可以直接使用你想暴露的成员覆盖module.exports
module.exports = sayHi
</code></pre>
<p>2.使用用户模块</p>
<pre><code class="lang-js">// 如何使用用户自定义模块：
// 所有模块想使用都要先引入
// 如果引入一个模块，那么这个模块默认会返回一个对象
var umodule = require(&#39;你想引入的模块路径&#39;)
umodule.sayHi()
</code></pre>
<h5 id="global-">global(了解即可)</h5>
<blockquote>
<p>相当于浏览器中的window,global是一个全局对象</p>
</blockquote>
<ul>
<li>全局变量污染</li>
<li>暴露的成员不明确：不知道成员是从哪个模块中暴露出去的</li>
<li>成员可能被覆盖</li>
<li>不建议使用</li>
</ul>
<pre><code class="lang-js">// 定义模块
// 我们所创建的js文件就可以认为是一个自定义模块
var obj = {
    name:&#39;jack&#39;,
    age:20
}
function sayHi(){
    console.log(&#39;我的名字叫：&#39;+obj.name+&quot;,我的年龄是：&quot;+obj.age)
}
// 在全局的global上挂载成员
global.fn = sayHi
global.obj = obj
---------------------------------------------------------
// 使用模块
require(&#39;模块路径&#39;)
global.fn()
console.log(global.obj)
</code></pre>
<h4 id="exports-module-exports-">exports 和 module.exports 的区别     暴露成员 ，提供外部使用</h4>
<ol>
<li>通过 module.exports 可以使用 . 的形式追加属性，也可以使用 等号 直接赋值的形式导出成员；</li>
<li>exports 只能通过 . 的形式追加属性；不能使用 等号 直接赋值的形式！</li>
<li><strong>注意</strong>： 在一个 module 中，最终向外暴露的成员，以 module.exports 指向的对象为准！</li>
<li>在一个模块中，不要混合使用 <code>module.exports</code> 和 <code>exports</code></li>
</ol>
<h4 id="-">使用用户自定义模块·</h4>
<p>1.定义用户自定义模块</p>
<p>2.引入并使用用户自定义模块</p>
<h3 id="-">模块查找(加载)规则    重要</h3>
<ol>
<li><p>优先从缓存中加载</p>
</li>
<li><p>加载核心模块:优先从缓存中加载；如果缓存中没有的话，再去执行加载核心模块，同时存储到缓存！</p>
</li>
<li><p>用户自定义模块:优先从缓存中加载；如果缓存中没有的话，再去执行加载用户模块！<strong>自定义模块加载的时候一定得指定路径</strong>(不能只指定模块名称，否则node 会把它当作内置模块或第三方模块进行加载)</p>
</li>
<li><p>内置模块是由 Node.js 官方提供的模块，内置模块的加载优先级最高，如果没有找到内置模块则再去查找第三方模块</p>
</li>
<li><p>在使用 require() 导入自定义模块时，如果省略了文件的扩展名，则 Node.js 会按顺序分别尝试加载以下的文件</p>
<p>① 按照确切的文件名进行加载</p>
<p>② <strong>==补全 .js 扩展名进行加载==</strong></p>
<p>③ 补全 .json 扩展名进行加载</p>
<p>④ 补全 .node 扩展名进行加载</p>
<p>⑤ 加载失败，终端报错</p>
</li>
<li><p>第三方模块查找规则：</p>
<ol>
<li>首先，查看项目根目录中有没有 <code>node_modules</code> 文件夹</li>
<li>查找 <code>node_modules</code> 文件夹中，有没有和第三方模块名称一致的文件夹</li>
<li>在模块对应的文件夹中，查找有没有 <code>package.json</code> 这个文件</li>
<li>在 <code>package.json</code> 文件中，查找有没有 <code>main</code> 属性</li>
<li>如果有 <code>main</code> 属性，并且 <code>main</code> 属性指向的路径存在，那么就尝试加载这个路径指定的文件！</li>
<li>如果 <code>package.json</code> 文件中，没有 <code>main</code> 属性，或者 <code>main</code> 属性指向的路径不存在，或者没有<code>package.json</code> 文件， 那么，Node尝试加载 模块根目录中 <code>index</code> 相关文件</li>
<li>如果在<code>node_modules</code>文件夹中，找不到对应的模块文件夹，或者在项目根目录中根本没有<code>node_modules</code>文件夹，则向上一层文件夹中去查找，查找规则同上！</li>
<li>如果上一层目录中也没有查找到，则再向上翻一层去查找，直到找到当前项目所在的盘符根目录为止！</li>
<li>如果找到当前盘符根目录还找不到，则报错：<strong><em>cannot find module</em></strong></li>
</ol>
</li>
</ol>
<h3 id="-">案例</h3>
<blockquote>
<p>创建一个node服务器，能够响应用户的注册页面请求，并能够实现注册业务逻辑</p>
<p>数据存储使用json文件</p>
<p>url后台可以自行约定</p>
<p>使用模块化实现当前业务功能</p>
</blockquote>
<h4 id="-">搭建案例目录结构</h4>
<p><img src="images\01-项目初始目录结构.png" alt=""></p>
<h4 id="-">项目中需要使用到的核心模块和第三方模块</h4>
<pre><code class="lang-js">const fs = require(&#39;fs&#39;)
const querystring = require(&#39;querystring&#39;)
const mime = require(&#39;mime&#39;)
</code></pre>
<h4 id="-">创建服务器</h4>
<pre><code class="lang-js">// 1.引入协议 
const http = require(&#39;http&#39;)

// 2.创建服务器
const server = http.createServer()

// 3.添加对端口的监听
server.listen(3004, function () {
    console.log(&#39;http://127.0.0.1:3004&#39;)
})
</code></pre>
<h4 id="-">添加用户请求的监听</h4>
<blockquote>
<p>完成注册页面的读取并返回</p>
<p>完成静态资源的处理</p>
<p>完成注册功能</p>
</blockquote>
<pre><code class="lang-js">// 4. 对用户请求的监听
server.on(&#39;request&#39;, function (req, res) {
    // 获取请求url
    let currentUrl = req.url
    console.log(currentUrl)
    // 获取请求方式
    let currentMethod = req.method

    // 判断用户请求url和请求method来进行对应的处理
    if (currentMethod == &#39;GET&#39; &amp;&amp; currentUrl == &#39;/register&#39;) {
        // 读取注册页面内容，并返回
        fs.readFile(__dirname + &#39;/views/register.html&#39;, function (err, data) {
            if (err) {
                res.end(&#39;err&#39;)
            } else {
                // 将读取到的整个页面返回
                res.end(data)
            }
        })
    }
    // 静态资源处理
    else if (currentUrl.indexOf(&#39;/css/&#39;) != -1 || currentUrl.indexOf(&#39;/js/&#39;) != -1) {
        fs.readFile(__dirname + currentUrl, function (err, data) {
            if (err) {
                res.end(&#39;404&#39;)
            } else {
                // 为静态资源设置mime响应头
                res.setHeader(&#39;Content-Type&#39;, mime.getType(req.url))
                res.end(data)
            }
        })
    } else if (currentUrl == &#39;/register&#39; &amp;&amp; currentMethod == &#39;POST&#39;) {
        // 接收参数
        let params = &#39;&#39;
        req.on(&#39;data&#39;, function (chunk) {
            params += chunk
        })
        res.setHeader(&#39;Content-Type&#39;,&#39;text/html;charset=utf-8&#39;)
        req.on(&#39;end&#39;, function () {
            console.log(params)
            // 使用核心模块querystring将参数字符串转换为对象
            let obj = querystring.parse(params)
            // 读取数据文件
            fs.readFile(__dirname + &quot;/data/users.json&quot;, (err, data) =&gt; {
                if (err) {
                    res.end(&#39;{&quot;code&quot;:201,&quot;msg&quot;:&quot;注册失败&quot;}&#39;)
                } else {
                    let arr = JSON.parse(data.toString())
                    // 添加数据到数组，实现注册
                    arr.push(obj)
                    fs.writeFile(__dirname + &quot;/data/users.json&quot;, JSON.stringify(arr, null, &#39; &#39;), (err) =&gt; {
                        if (err) {
                            res.end(&#39;{&quot;code&quot;:201,&quot;msg&quot;:&quot;注册失败&quot;}&#39;)
                        } else {
                            res.end(&#39;{&quot;code&quot;:200,&quot;msg&quot;:&quot;注册成功&quot;}&#39;)
                        }
                    })
                }
            })
        })

    }
})
</code></pre>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>